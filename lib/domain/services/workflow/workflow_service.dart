import 'package:taskly_bloc/domain/interfaces/workflow_repository_contract.dart';
import 'package:taskly_bloc/domain/workflow/model/workflow.dart';
import 'package:taskly_bloc/domain/workflow/model/workflow_definition.dart';
import 'package:taskly_bloc/domain/workflow/model/workflow_step.dart';
import 'package:taskly_bloc/domain/workflow/model/workflow_step_state.dart';

/// Service for orchestrating multi-step workflows.
///
/// Handles workflow lifecycle, step progression, and state management.
/// Entity fetching for workflow steps happens in WorkflowRunBloc via
/// ScreenQueryBuilder and SectionDataService.
class WorkflowService {
  WorkflowService({
    required WorkflowRepositoryContract workflowRepository,
  }) : _workflowRepository = workflowRepository;

  final WorkflowRepositoryContract _workflowRepository;

  /// Start a new workflow from a definition
  Future<Workflow> startWorkflow({
    required WorkflowDefinition definition,
  }) async {
    // Create initial step states
    final stepStates = List.generate(
      definition.steps.length,
      (index) => WorkflowStepState(
        stepIndex: index,
      ),
    );

    final workflow = Workflow(
      id: '', // Will be generated by repository
      workflowDefinitionId: definition.id,
      status: WorkflowStatus.inProgress,
      stepStates: stepStates,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );

    return _workflowRepository.createWorkflow(workflow);
  }

  /// Watch a running workflow
  Stream<Workflow> watchWorkflow(String workflowId) {
    return _workflowRepository.watchWorkflow(workflowId);
  }

  /// Get the current step for a workflow
  WorkflowStep getCurrentStep(
    WorkflowDefinition definition,
    Workflow workflow,
  ) {
    if (workflow.currentStepIndex >= definition.steps.length) {
      throw StateError('Workflow step index out of bounds');
    }
    return definition.steps[workflow.currentStepIndex];
  }

  /// Get the current step state
  WorkflowStepState getCurrentStepState(Workflow workflow) {
    if (workflow.currentStepIndex >= workflow.stepStates.length) {
      throw StateError('Workflow step state index out of bounds');
    }
    return workflow.stepStates[workflow.currentStepIndex];
  }

  /// Mark an entity as reviewed in the current step
  Future<void> markEntityReviewed({
    required Workflow workflow,
    required String entityId,
  }) async {
    final currentState = getCurrentStepState(workflow);
    final updatedState = WorkflowStepState(
      stepIndex: currentState.stepIndex,
      reviewedEntityIds: [...currentState.reviewedEntityIds, entityId],
      skippedEntityIds: currentState.skippedEntityIds,
      pendingEntityIds: currentState.pendingEntityIds
          .where((id) => id != entityId)
          .toList(),
    );

    final updatedStepStates = [...workflow.stepStates];
    updatedStepStates[workflow.currentStepIndex] = updatedState;

    final updatedWorkflow = Workflow(
      id: workflow.id,
      workflowDefinitionId: workflow.workflowDefinitionId,
      status: workflow.status,
      stepStates: updatedStepStates,
      createdAt: workflow.createdAt,
      updatedAt: DateTime.now(),
      currentStepIndex: workflow.currentStepIndex,
      completedAt: workflow.completedAt,
    );

    await _workflowRepository.updateWorkflow(updatedWorkflow);
  }

  /// Skip an entity in the current step
  Future<void> skipEntity({
    required Workflow workflow,
    required String entityId,
  }) async {
    final currentState = getCurrentStepState(workflow);
    final updatedState = WorkflowStepState(
      stepIndex: currentState.stepIndex,
      reviewedEntityIds: currentState.reviewedEntityIds,
      skippedEntityIds: [...currentState.skippedEntityIds, entityId],
      pendingEntityIds: currentState.pendingEntityIds
          .where((id) => id != entityId)
          .toList(),
    );

    final updatedStepStates = [...workflow.stepStates];
    updatedStepStates[workflow.currentStepIndex] = updatedState;

    final updatedWorkflow = Workflow(
      id: workflow.id,
      workflowDefinitionId: workflow.workflowDefinitionId,
      status: workflow.status,
      stepStates: updatedStepStates,
      createdAt: workflow.createdAt,
      updatedAt: DateTime.now(),
      currentStepIndex: workflow.currentStepIndex,
      completedAt: workflow.completedAt,
    );

    await _workflowRepository.updateWorkflow(updatedWorkflow);
  }

  /// Advance to the next step
  Future<void> advanceToNextStep(Workflow workflow) async {
    final nextStepIndex = workflow.currentStepIndex + 1;

    final updatedWorkflow = Workflow(
      id: workflow.id,
      workflowDefinitionId: workflow.workflowDefinitionId,
      status: workflow.status,
      stepStates: workflow.stepStates,
      createdAt: workflow.createdAt,
      updatedAt: DateTime.now(),
      currentStepIndex: nextStepIndex,
      completedAt: workflow.completedAt,
    );

    await _workflowRepository.updateWorkflow(updatedWorkflow);
  }

  /// Complete the workflow
  Future<void> completeWorkflow(Workflow workflow) async {
    final updatedWorkflow = Workflow(
      id: workflow.id,
      workflowDefinitionId: workflow.workflowDefinitionId,
      status: WorkflowStatus.completed,
      stepStates: workflow.stepStates,
      createdAt: workflow.createdAt,
      updatedAt: DateTime.now(),
      currentStepIndex: workflow.currentStepIndex,
      completedAt: DateTime.now(),
    );

    await _workflowRepository.updateWorkflow(updatedWorkflow);
  }

  /// Abandon the workflow
  Future<void> abandonWorkflow(Workflow workflow) async {
    final updatedWorkflow = Workflow(
      id: workflow.id,
      workflowDefinitionId: workflow.workflowDefinitionId,
      status: WorkflowStatus.abandoned,
      stepStates: workflow.stepStates,
      createdAt: workflow.createdAt,
      updatedAt: DateTime.now(),
      currentStepIndex: workflow.currentStepIndex,
      completedAt: workflow.completedAt,
    );

    await _workflowRepository.updateWorkflow(updatedWorkflow);
  }

  /// Check if the current step is complete
  bool isCurrentStepComplete(Workflow workflow, int totalEntities) {
    final currentState = getCurrentStepState(workflow);
    final processedCount =
        currentState.reviewedEntityIds.length +
        currentState.skippedEntityIds.length;
    return processedCount >= totalEntities;
  }

  /// Check if the workflow is complete
  bool isWorkflowComplete(
    WorkflowDefinition definition,
    Workflow workflow,
  ) {
    return workflow.currentStepIndex >= definition.steps.length;
  }
}
